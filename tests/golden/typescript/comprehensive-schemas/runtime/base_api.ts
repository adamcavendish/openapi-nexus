// DO NOT EDIT - This file is automatically generated.
// Any manual changes will be overwritten on the next generation.
// To make changes, modify the source code and regenerate this file.

export abstract class BaseAPI<T = any> {
    protected configuration: Configuration;
    protected middleware: Middleware[];
    protected static jsonRegex: RegExp;

    constructor(configuration: Configuration = DefaultConfig) {
        this.configuration = configuration;
        this.middleware = configuration.middleware;
        BaseAPI.jsonRegex = new RegExp('^(:?application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(:?;.*)?$', 'i');
    }

    withMiddleware<T>(...middlewares: Middleware[]): T {
        const next = this.clone<T>();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }

    withPreMiddleware<T>(preMiddlewares: Array<Middleware['pre']>): T {
        const middlewares = preMiddlewares.map((pre) => ({ pre }));
        return this.withMiddleware<T>(...middlewares);
    }

    withPostMiddleware<T>(postMiddlewares: Array<Middleware['post']>): T {
        const middlewares = postMiddlewares.map((post) => ({ post }));
        return this.withMiddleware<T>(...middlewares);
    }

    protected isJsonMime(mime: string | null | undefined): boolean {
        if (!mime) { return false; }
        return BaseAPI.jsonRegex.test(mime);
    }

    protected async request(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction): Promise<Response> {
        const { url, init } = await this.createFetchParams(context, initOverrides);
        const response = await this.fetchApi(url, init);
        if (response && (response.status >= 200 && response.status < 300)) {
            return response;
        }
        throw new ResponseError(response, 'Response returned an error code');
    }

    private async createFetchParams(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction): Promise<{ url: string; init: RequestInit }> {
        let url = this.configuration.basePath + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
            url += '?' + this.configuration.queryParamsStringify(context.query);
        }
        const headers = Object.assign({}, this.configuration.headers, context.headers);
        Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});
        const initOverrideFn = typeof initOverrides === "function" ? initOverrides : async () => initOverrides;
        const initParams = { method: context.method, headers, body: context.body, credentials: this.configuration.credentials };
        const overriddenInit: RequestInit = { ...initParams, ...(await initOverrideFn({ init: initParams, context })) };
        let body: any;
        if (isFormData(overriddenInit.body) || (overriddenInit.body instanceof URLSearchParams) || isBlob(overriddenInit.body)) {
            body = overriddenInit.body;
        } else if (this.isJsonMime(headers['Content-Type'])) {
            body = JSON.stringify(overriddenInit.body);
        } else {
            body = overriddenInit.body;
        }
        const init: RequestInit = { ...overriddenInit, body };
        return { url, init };
    }

    private async fetchApi(url: string, init: RequestInit): Promise<Response> {
        let fetchParams = { url, init };
        for (const middleware of this.middleware) {
            if (middleware.pre) {
                fetchParams = await middleware.pre({ fetch: this.fetchApi, ...fetchParams }) || fetchParams;
            }
        }
        let response: Response | undefined = undefined;
        try {
            response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
        } catch (e) {
            for (const middleware of this.middleware) {
                if (middleware.onError) {
                    response = await middleware.onError({ fetch: this.fetchApi, url: fetchParams.url, init: fetchParams.init, error: e, response: response ? response.clone() : undefined }) || response;
                }
            }
            if (response === undefined) {
                if (e instanceof Error) {
                    throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');
                } else {
                    throw e;
                }
            }
        }
        for (const middleware of this.middleware) {
            if (middleware.post) {
                response = await middleware.post({ fetch: this.fetchApi, url: fetchParams.url, init: fetchParams.init, response: response.clone() }) || response;
            }
        }
        return response;
    }

    private clone<T>(): T {
        const constructor = this.constructor as any;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
}

// DO NOT EDIT - This file is automatically generated.
// Any manual changes will be overwritten on the next generation.
// To make changes, modify the source code and regenerate this file.


import BaseAPI from '../runtime/base_api';

import Configuration from '../runtime/configuration';

import JSONApiResponse from '../runtime/classes/json_api_response';

import ResponseError from '../runtime/classes/response_error';



/** API client for store operations */

export class StoreApi extends BaseAPI {



  
    /** Initialize the API client */
  
  constructor(configuration: Configuration) {
    
    this.configuration = configuration;
    
  }




  
    /** Returns pet inventories by status */
  
  async getInventory(): Promise<JSONApiResponse<string>> {
    
      // Build URL with path parameters
  const url = `${this.configuration?.basePath || ''}`;

  // Build query parameters
  const queryParams = new URLSearchParams();


  // Build headers
  const headers: Record<string, string> = {
    ...this.configuration?.headers,
  };

  // Add header parameters


  // Add authentication
  if (this.configuration?.apiKey) {
    headers['X-API-Key'] = this.configuration.apiKey;
  }
  if (this.configuration?.accessToken) {
    headers['Authorization'] = `Bearer ${this.configuration.accessToken}`;
  }
  if (this.configuration?.username && this.configuration?.password) {
    const credentials = btoa(`${this.configuration.username}:${this.configuration.password}`);
    headers['Authorization'] = `Basic ${credentials}`;
  }

  // Build final URL
  const finalUrl = queryParams.toString() 
    ? `${url}?${queryParams.toString()}`
    : url;

  // Make request and return response with error handling
  return this.request({
    url: finalUrl,
    init: {
      method: 'GET',
      headers,
    },
  }).then(response => {
    if (response.ok) {
      return response.json().then(data => new JSONApiResponse(data, response));
    } else {
      throw new ResponseError(response, 'Request failed');
    }
  });
    
  }




  
    /** Place an order for a pet */
  
  async placeOrder(body: Order): Promise<JSONApiResponse<Order>> {
    
      // Build URL with path parameters
  const url = `${this.configuration?.basePath || ''}`;

  // Build query parameters
  const queryParams = new URLSearchParams();


  // Build headers
  const headers: Record<string, string> = {
    
    ...this.configuration?.headers,
  };

  // Add header parameters


  // Add authentication
  if (this.configuration?.apiKey) {
    headers['X-API-Key'] = this.configuration.apiKey;
  }
  if (this.configuration?.accessToken) {
    headers['Authorization'] = `Bearer ${this.configuration.accessToken}`;
  }
  if (this.configuration?.username && this.configuration?.password) {
    const credentials = btoa(`${this.configuration.username}:${this.configuration.password}`);
    headers['Authorization'] = `Basic ${credentials}`;
  }

  // Build final URL
  const finalUrl = queryParams.toString() 
    ? `${url}?${queryParams.toString()}`
    : url;

  // Prepare request body

  const body = undefined;


  // Make request and return response with error handling
  return this.request({
    url: finalUrl,
    init: {
      method: '',
      headers,
      body,
    },
  }).then(response => {
    if (response.ok) {
      return response.json().then(data => new JSONApiResponse(data, response));
    } else {
      throw new ResponseError(response, 'Request failed');
    }
  });
    
  }




  
    /** Find purchase order by ID */
  
  async getOrderById(orderId: string): Promise<JSONApiResponse<Order>> {
    
      // Build URL with path parameters
  const url = `${this.configuration?.basePath || ''}`;

  // Build query parameters
  const queryParams = new URLSearchParams();


  // Build headers
  const headers: Record<string, string> = {
    ...this.configuration?.headers,
  };

  // Add header parameters


  // Add authentication
  if (this.configuration?.apiKey) {
    headers['X-API-Key'] = this.configuration.apiKey;
  }
  if (this.configuration?.accessToken) {
    headers['Authorization'] = `Bearer ${this.configuration.accessToken}`;
  }
  if (this.configuration?.username && this.configuration?.password) {
    const credentials = btoa(`${this.configuration.username}:${this.configuration.password}`);
    headers['Authorization'] = `Basic ${credentials}`;
  }

  // Build final URL
  const finalUrl = queryParams.toString() 
    ? `${url}?${queryParams.toString()}`
    : url;

  // Make request and return response with error handling
  return this.request({
    url: finalUrl,
    init: {
      method: 'GET',
      headers,
    },
  }).then(response => {
    if (response.ok) {
      return response.json().then(data => new JSONApiResponse(data, response));
    } else {
      throw new ResponseError(response, 'Request failed');
    }
  });
    
  }




  
    /** Delete purchase order by ID */
  
  async deleteOrder(orderId: string): Promise<JSONApiResponse<any>> {
    
      // Build URL with path parameters
  const url = `${this.configuration?.basePath || ''}`;

  // Build query parameters
  const queryParams = new URLSearchParams();


  // Build headers
  const headers: Record<string, string> = {
    ...this.configuration?.headers,
  };

  // Add header parameters


  // Add authentication
  if (this.configuration?.apiKey) {
    headers['X-API-Key'] = this.configuration.apiKey;
  }
  if (this.configuration?.accessToken) {
    headers['Authorization'] = `Bearer ${this.configuration.accessToken}`;
  }
  if (this.configuration?.username && this.configuration?.password) {
    const credentials = btoa(`${this.configuration.username}:${this.configuration.password}`);
    headers['Authorization'] = `Basic ${credentials}`;
  }

  // Build final URL
  const finalUrl = queryParams.toString() 
    ? `${url}?${queryParams.toString()}`
    : url;

  // Make request and return response with error handling
  return this.request({
    url: finalUrl,
    init: {
      method: 'DELETE',
      headers,
    },
  }).then(response => {
    if (response.ok) {
      return new VoidApiResponse(response);
    } else {
      throw new ResponseError(response, 'Request failed');
    }
  });
    
  }


}
// DO NOT EDIT - This file is automatically generated.
// Any manual changes will be overwritten on the next generation.
// To make changes, modify the source code and regenerate this file.


import { BaseAPI } from '../runtime/base_api';

import { type Configuration } from '../runtime/configuration';

import { JSONApiResponse } from '../runtime/classes/json_api_response';

import { ResponseError } from '../runtime/classes/response_error';



/** API client for pet operations */

export class PetApi extends BaseAPI {



  
    /** Initialize the API client */
  
  constructor(configuration: Configuration) {
    
    this.configuration = configuration;
    
  }




  
    /** Add a new pet to the store */
  
  async addPet(body: Pet): Promise<JSONApiResponse<Pet>> {
    
      // Build URL with path parameters
  const url = `${this.configuration?.basePath || ''}`;

  // Build query parameters
  const queryParams = new URLSearchParams();


  // Build headers
  const headers: Record<string, string> = {
    
    ...this.configuration?.headers,
  };

  // Add header parameters


  // Add authentication
  if (this.configuration?.apiKey) {
    headers['X-API-Key'] = this.configuration.apiKey;
  }
  if (this.configuration?.accessToken) {
    headers['Authorization'] = `Bearer ${this.configuration.accessToken}`;
  }
  if (this.configuration?.username && this.configuration?.password) {
    const credentials = btoa(`${this.configuration.username}:${this.configuration.password}`);
    headers['Authorization'] = `Basic ${credentials}`;
  }

  // Build final URL
  const finalUrl = queryParams.toString() 
    ? `${url}?${queryParams.toString()}`
    : url;

  // Prepare request body

  const body = undefined;


  // Make request and return response with error handling
  return this.request({
    url: finalUrl,
    init: {
      method: '',
      headers,
      body,
    },
  }).then(response => {
    if (response.ok) {
      return response.json().then(data => new JSONApiResponse(data, response));
    } else {
      throw new ResponseError(response, 'Request failed');
    }
  });
    
  }




  
    /** Update an existing pet */
  
  async updatePet(body: Pet): Promise<JSONApiResponse<Pet>> {
    
      // Build URL with path parameters
  const url = `${this.configuration?.basePath || ''}`;

  // Build query parameters
  const queryParams = new URLSearchParams();


  // Build headers
  const headers: Record<string, string> = {
    
    ...this.configuration?.headers,
  };

  // Add header parameters


  // Add authentication
  if (this.configuration?.apiKey) {
    headers['X-API-Key'] = this.configuration.apiKey;
  }
  if (this.configuration?.accessToken) {
    headers['Authorization'] = `Bearer ${this.configuration.accessToken}`;
  }
  if (this.configuration?.username && this.configuration?.password) {
    const credentials = btoa(`${this.configuration.username}:${this.configuration.password}`);
    headers['Authorization'] = `Basic ${credentials}`;
  }

  // Build final URL
  const finalUrl = queryParams.toString() 
    ? `${url}?${queryParams.toString()}`
    : url;

  // Prepare request body

  const body = undefined;


  // Make request and return response with error handling
  return this.request({
    url: finalUrl,
    init: {
      method: '',
      headers,
      body,
    },
  }).then(response => {
    if (response.ok) {
      return response.json().then(data => new JSONApiResponse(data, response));
    } else {
      throw new ResponseError(response, 'Request failed');
    }
  });
    
  }




  
    /** Find pets by status */
  
  async findPetsByStatus(status: string): Promise<JSONApiResponse<Array<string>>> {
    
      // Build URL with path parameters
  const url = `${this.configuration?.basePath || ''}`;

  // Build query parameters
  const queryParams = new URLSearchParams();


  // Build headers
  const headers: Record<string, string> = {
    ...this.configuration?.headers,
  };

  // Add header parameters


  // Add authentication
  if (this.configuration?.apiKey) {
    headers['X-API-Key'] = this.configuration.apiKey;
  }
  if (this.configuration?.accessToken) {
    headers['Authorization'] = `Bearer ${this.configuration.accessToken}`;
  }
  if (this.configuration?.username && this.configuration?.password) {
    const credentials = btoa(`${this.configuration.username}:${this.configuration.password}`);
    headers['Authorization'] = `Basic ${credentials}`;
  }

  // Build final URL
  const finalUrl = queryParams.toString() 
    ? `${url}?${queryParams.toString()}`
    : url;

  // Make request and return response with error handling
  return this.request({
    url: finalUrl,
    init: {
      method: 'GET',
      headers,
    },
  }).then(response => {
    if (response.ok) {
      return response.json().then(data => new JSONApiResponse(data, response));
    } else {
      throw new ResponseError(response, 'Request failed');
    }
  });
    
  }




  
    /** Find pets by tags */
  
  async findPetsByTags(tags: Array<string>): Promise<JSONApiResponse<Array<string>>> {
    
      // Build URL with path parameters
  const url = `${this.configuration?.basePath || ''}`;

  // Build query parameters
  const queryParams = new URLSearchParams();


  // Build headers
  const headers: Record<string, string> = {
    ...this.configuration?.headers,
  };

  // Add header parameters


  // Add authentication
  if (this.configuration?.apiKey) {
    headers['X-API-Key'] = this.configuration.apiKey;
  }
  if (this.configuration?.accessToken) {
    headers['Authorization'] = `Bearer ${this.configuration.accessToken}`;
  }
  if (this.configuration?.username && this.configuration?.password) {
    const credentials = btoa(`${this.configuration.username}:${this.configuration.password}`);
    headers['Authorization'] = `Basic ${credentials}`;
  }

  // Build final URL
  const finalUrl = queryParams.toString() 
    ? `${url}?${queryParams.toString()}`
    : url;

  // Make request and return response with error handling
  return this.request({
    url: finalUrl,
    init: {
      method: 'GET',
      headers,
    },
  }).then(response => {
    if (response.ok) {
      return response.json().then(data => new JSONApiResponse(data, response));
    } else {
      throw new ResponseError(response, 'Request failed');
    }
  });
    
  }




  
    /** Find pet by ID */
  
  async getPetById(petId: string): Promise<JSONApiResponse<Pet>> {
    
      // Build URL with path parameters
  const url = `${this.configuration?.basePath || ''}`;

  // Build query parameters
  const queryParams = new URLSearchParams();


  // Build headers
  const headers: Record<string, string> = {
    ...this.configuration?.headers,
  };

  // Add header parameters


  // Add authentication
  if (this.configuration?.apiKey) {
    headers['X-API-Key'] = this.configuration.apiKey;
  }
  if (this.configuration?.accessToken) {
    headers['Authorization'] = `Bearer ${this.configuration.accessToken}`;
  }
  if (this.configuration?.username && this.configuration?.password) {
    const credentials = btoa(`${this.configuration.username}:${this.configuration.password}`);
    headers['Authorization'] = `Basic ${credentials}`;
  }

  // Build final URL
  const finalUrl = queryParams.toString() 
    ? `${url}?${queryParams.toString()}`
    : url;

  // Make request and return response with error handling
  return this.request({
    url: finalUrl,
    init: {
      method: 'GET',
      headers,
    },
  }).then(response => {
    if (response.ok) {
      return response.json().then(data => new JSONApiResponse(data, response));
    } else {
      throw new ResponseError(response, 'Request failed');
    }
  });
    
  }




  
    /** Update a pet in the store with form data */
  
  async updatePetWithForm(petId: string, name: string, status: string): Promise<JSONApiResponse<Pet>> {
    
      // Build URL with path parameters
  const url = `${this.configuration?.basePath || ''}`;

  // Build query parameters
  const queryParams = new URLSearchParams();


  // Build headers
  const headers: Record<string, string> = {
    
    ...this.configuration?.headers,
  };

  // Add header parameters


  // Add authentication
  if (this.configuration?.apiKey) {
    headers['X-API-Key'] = this.configuration.apiKey;
  }
  if (this.configuration?.accessToken) {
    headers['Authorization'] = `Bearer ${this.configuration.accessToken}`;
  }
  if (this.configuration?.username && this.configuration?.password) {
    const credentials = btoa(`${this.configuration.username}:${this.configuration.password}`);
    headers['Authorization'] = `Basic ${credentials}`;
  }

  // Build final URL
  const finalUrl = queryParams.toString() 
    ? `${url}?${queryParams.toString()}`
    : url;

  // Prepare request body

  const body = undefined;


  // Make request and return response with error handling
  return this.request({
    url: finalUrl,
    init: {
      method: '',
      headers,
      body,
    },
  }).then(response => {
    if (response.ok) {
      return response.json().then(data => new JSONApiResponse(data, response));
    } else {
      throw new ResponseError(response, 'Request failed');
    }
  });
    
  }




  
    /** Delete a pet */
  
  async deletePet(petId: string): Promise<JSONApiResponse<any>> {
    
      // Build URL with path parameters
  const url = `${this.configuration?.basePath || ''}`;

  // Build query parameters
  const queryParams = new URLSearchParams();


  // Build headers
  const headers: Record<string, string> = {
    ...this.configuration?.headers,
  };

  // Add header parameters


  // Add authentication
  if (this.configuration?.apiKey) {
    headers['X-API-Key'] = this.configuration.apiKey;
  }
  if (this.configuration?.accessToken) {
    headers['Authorization'] = `Bearer ${this.configuration.accessToken}`;
  }
  if (this.configuration?.username && this.configuration?.password) {
    const credentials = btoa(`${this.configuration.username}:${this.configuration.password}`);
    headers['Authorization'] = `Basic ${credentials}`;
  }

  // Build final URL
  const finalUrl = queryParams.toString() 
    ? `${url}?${queryParams.toString()}`
    : url;

  // Make request and return response with error handling
  return this.request({
    url: finalUrl,
    init: {
      method: 'DELETE',
      headers,
    },
  }).then(response => {
    if (response.ok) {
      return new VoidApiResponse(response);
    } else {
      throw new ResponseError(response, 'Request failed');
    }
  });
    
  }




  
    /** Upload an image */
  
  async uploadFile(petId: string, additionalMetadata: string): Promise<JSONApiResponse<ApiResponse>> {
    
      // Build URL with path parameters
  const url = `${this.configuration?.basePath || ''}`;

  // Build query parameters
  const queryParams = new URLSearchParams();


  // Build headers
  const headers: Record<string, string> = {
    
    ...this.configuration?.headers,
  };

  // Add header parameters


  // Add authentication
  if (this.configuration?.apiKey) {
    headers['X-API-Key'] = this.configuration.apiKey;
  }
  if (this.configuration?.accessToken) {
    headers['Authorization'] = `Bearer ${this.configuration.accessToken}`;
  }
  if (this.configuration?.username && this.configuration?.password) {
    const credentials = btoa(`${this.configuration.username}:${this.configuration.password}`);
    headers['Authorization'] = `Basic ${credentials}`;
  }

  // Build final URL
  const finalUrl = queryParams.toString() 
    ? `${url}?${queryParams.toString()}`
    : url;

  // Prepare request body

  const body = undefined;


  // Make request and return response with error handling
  return this.request({
    url: finalUrl,
    init: {
      method: '',
      headers,
      body,
    },
  }).then(response => {
    if (response.ok) {
      return response.json().then(data => new JSONApiResponse(data, response));
    } else {
      throw new ResponseError(response, 'Request failed');
    }
  });
    
  }


}
//! TypeScript code emitter

use pretty::RcDoc;

use crate::ast::{TsClassDefinition, TsNode, TsTypeDefinition};
use crate::emission::error::EmitError;
use crate::templating::TemplatingEmitter;
use openapi_nexus_core::traits::{EmissionContext, ToRcDocWithContext};

const GENERATED_HEADER: &str = r#"// DO NOT EDIT - This file is automatically generated.
// Any manual changes will be overwritten on the next generation.
// To make changes, modify the source code and regenerate this file."#;

/// OpenAPI specification metadata for file headers
#[derive(Debug, Clone)]
pub struct OpenApiMetadata {
    pub title: Option<String>,
    pub description: Option<String>,
    pub version: Option<String>,
}

impl Default for OpenApiMetadata {
    fn default() -> Self {
        Self {
            title: None,
            description: None,
            version: None,
        }
    }
}

/// TypeScript code emitter that routes between template and RcDoc paths
#[derive(Debug, Clone)]
pub struct TsLanguageEmitter {
    templating: TemplatingEmitter,
    metadata: OpenApiMetadata,
}

impl TsLanguageEmitter {
    /// Create a new TypeScript emitter
    pub fn new(max_line_width: usize) -> Self {
        Self {
            templating: TemplatingEmitter::new(max_line_width),
            metadata: OpenApiMetadata::default(),
        }
    }

    /// Create a new TypeScript emitter with OpenAPI metadata
    pub fn with_metadata(max_line_width: usize, metadata: OpenApiMetadata) -> Self {
        Self {
            templating: TemplatingEmitter::new(max_line_width),
            metadata,
        }
    }

    /// Emit TypeScript code from a class definition (template-based)
    pub fn emit_class(&self, class: &TsClassDefinition) -> Result<String, EmitError> {
        self.templating.emit_class(class)
    }

    /// Emit TypeScript code from type definitions (RcDoc-based)
    pub fn emit_type_definitions(
        &self,
        type_defs: &[&TsTypeDefinition],
    ) -> Result<String, EmitError> {
        if type_defs.is_empty() {
            return Ok(String::new());
        }

        let context = EmissionContext::default();
        let mut docs = Vec::new();

        // Add generated file header
        docs.push(RcDoc::text(self.get_default_header()));

        // Convert type definitions to RcDoc
        for type_def in type_defs {
            let doc = type_def.to_rcdoc_with_context(&context)?;
            docs.push(doc);
        }

        let combined = RcDoc::intersperse(docs, RcDoc::line().append(RcDoc::line()));
        Ok(combined.pretty(80).to_string())
    }

    /// Emit TypeScript code from AST nodes (legacy compatibility)
    pub fn emit(&self, nodes: &[TsNode]) -> Result<String, EmitError> {
        let context = EmissionContext::default();
        self.emit_with_context(nodes, &context)
    }

    /// Emit TypeScript code from AST nodes with context
    pub fn emit_with_context(
        &self,
        nodes: &[TsNode],
        context: &EmissionContext,
    ) -> Result<String, EmitError> {
        let mut docs = Vec::new();

        // Add generated file header
        docs.push(RcDoc::text(self.get_default_header()));

        // Process nodes based on type
        for node in nodes {
            match node {
                TsNode::Class(class) => {
                    let class_code = self.templating.emit_class(class)?;
                    docs.push(RcDoc::text(class_code));
                }
                TsNode::TypeDefinition(type_def) => {
                    // Use RcDoc-based emission for type definitions
                    let doc = type_def.to_rcdoc_with_context(context)?;
                    docs.push(doc);
                }
                TsNode::Import(import) => {
                    // Use RcDoc-based emission for imports
                    let doc = import.to_rcdoc_with_context(context)?;
                    docs.push(doc);
                }
            }
        }

        let combined = RcDoc::intersperse(docs, RcDoc::line().append(RcDoc::line()));
        Ok(combined.pretty(80).to_string())
    }

    /// Get default file header
    fn get_default_header(&self) -> String {
        // If we have metadata, use the enhanced header
        if self.metadata.title.is_some()
            || self.metadata.description.is_some()
            || self.metadata.version.is_some()
        {
            self.get_enhanced_header()
        } else {
            GENERATED_HEADER.to_string()
        }
    }

    /// Get enhanced file header with OpenAPI metadata
    fn get_enhanced_header(&self) -> String {
        let mut lines = vec![];

        // Add linter disable comments
        lines.push("/* tslint:disable */".to_string());
        lines.push("/* eslint-disable */".to_string());

        // Add OpenAPI documentation block
        lines.push("/**".to_string());

        if let Some(ref title) = self.metadata.title {
            lines.push(format!(" * {}", title));
        }

        if let Some(ref description) = self.metadata.description {
            if lines.last() != Some(&"/**".to_string()) {
                lines.push(" *".to_string());
            }
            // Split description into lines and add them
            for line in description.lines() {
                let trimmed = line.trim();
                if !trimmed.is_empty() {
                    lines.push(format!(" * {}", trimmed));
                }
            }
        }

        if let Some(ref version) = self.metadata.version {
            lines.push(" *".to_string());
            lines.push(format!(
                " * The version of the OpenAPI document: {}",
                version
            ));
        }

        lines.push(" *".to_string());
        lines.push(" * NOTE: This class is auto generated by openapi-nexus.".to_string());
        lines.push(" * https://github.com/adamcavendish/openapi-nexus".to_string());
        lines.push(" * Do not edit the class manually.".to_string());
        lines.push(" */".to_string());

        lines.join("\n")
    }
}

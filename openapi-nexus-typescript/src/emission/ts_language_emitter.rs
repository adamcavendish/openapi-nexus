//! TypeScript code emitter

use pretty::RcDoc;

use crate::ast::{ClassDefinition, TsNode, TypeDefinition, TypeScriptFile};
use crate::emission::error::EmitError;
use crate::templating::Templating;
use openapi_nexus_core::traits::{EmissionContext, ToRcDocWithContext};

const GENERATED_HEADER: &str = r#"// DO NOT EDIT - This file is automatically generated.
// Any manual changes will be overwritten on the next generation.
// To make changes, modify the source code and regenerate this file."#;

/// TypeScript code emitter that routes between template and RcDoc paths
#[derive(Debug, Clone)]
pub struct TsLanguageEmitter {
    templating: Templating,
}

impl TsLanguageEmitter {
    /// Create a new TypeScript emitter
    pub fn new(max_line_width: usize) -> Self {
        Self {
            templating: Templating::new(max_line_width),
        }
    }

    /// Emit TypeScript code from a file (routes to appropriate emitter)
    pub fn emit_file(&self, file: &TypeScriptFile) -> Result<String, EmitError> {
        if file.needs_template_rendering() {
            // Use template-based emission for API classes
            self.templating.emit_file(file)
        } else {
            // Use RcDoc-based emission for type definitions
            self.emit_type_definitions(&file.get_type_definitions())
        }
    }

    /// Emit TypeScript code from a class definition (template-based)
    pub fn emit_class(&self, class: &ClassDefinition) -> Result<String, EmitError> {
        self.templating.emit_class(class)
    }

    /// Emit TypeScript code from type definitions (RcDoc-based)
    pub fn emit_type_definitions(
        &self,
        type_defs: &[&TypeDefinition],
    ) -> Result<String, EmitError> {
        if type_defs.is_empty() {
            return Ok(String::new());
        }

        let context = EmissionContext::default();
        let mut docs = Vec::new();

        // Add generated file header
        docs.push(RcDoc::text(self.get_default_header()));

        // Convert type definitions to RcDoc
        for type_def in type_defs {
            let doc = type_def.to_rcdoc_with_context(&context)?;
            docs.push(doc);
        }

        let combined = RcDoc::intersperse(docs, RcDoc::line().append(RcDoc::line()));
        Ok(combined.pretty(80).to_string())
    }

    /// Emit TypeScript code from AST nodes (legacy compatibility)
    pub fn emit(&self, nodes: &[TsNode]) -> Result<String, EmitError> {
        let context = EmissionContext::default();
        self.emit_with_context(nodes, &context)
    }

    /// Emit TypeScript code from AST nodes with context
    pub fn emit_with_context(
        &self,
        nodes: &[TsNode],
        context: &EmissionContext,
    ) -> Result<String, EmitError> {
        let mut docs = Vec::new();

        // Add generated file header
        docs.push(RcDoc::text(self.get_default_header()));

        // Process nodes based on type
        for node in nodes {
            match node {
                TsNode::Class(class) => {
                    let class_code = self.templating.emit_class(class)?;
                    docs.push(RcDoc::text(class_code));
                }
                TsNode::TypeDefinition(type_def) => {
                    // Use RcDoc-based emission for type definitions
                    let doc = type_def.to_rcdoc_with_context(context)?;
                    docs.push(doc);
                }
                TsNode::Import(import) => {
                    // Use RcDoc-based emission for imports
                    let doc = import.to_rcdoc_with_context(context)?;
                    docs.push(doc);
                }
            }
        }

        let combined = RcDoc::intersperse(docs, RcDoc::line().append(RcDoc::line()));
        Ok(combined.pretty(80).to_string())
    }

    /// Get default file header
    fn get_default_header(&self) -> String {
        GENERATED_HEADER.to_string()
    }
}

//! TypeScript metadata and documentation
//!
//! This module consolidates comment handling, documentation, and file headers.

use serde::{Deserialize, Serialize};

/// TypeScript documentation comment
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DocComment {
    pub content: String,
    pub is_multiline: bool,
}

/// Simple TypeScript comment
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Comment {
    pub content: String,
    pub is_block: bool,
}

/// Generated file header
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GeneratedFileHeader {
    pub warning_message: String,
    pub generator_info: Option<String>,
    pub timestamp: Option<String>,
}

impl DocComment {
    /// Create a new documentation comment
    pub fn new(content: String) -> Self {
        let is_multiline = content.contains('\n');
        Self {
            content,
            is_multiline,
        }
    }

    /// Create a single-line doc comment
    pub fn single_line(content: String) -> Self {
        Self {
            content,
            is_multiline: false,
        }
    }

    /// Create a multi-line doc comment
    pub fn multi_line(content: String) -> Self {
        Self {
            content,
            is_multiline: true,
        }
    }

    /// Format as TypeScript documentation comment
    pub fn to_typescript_string(&self) -> String {
        if self.is_multiline {
            let lines: Vec<&str> = self.content.lines().collect();
            let mut result = String::from("/**\n");
            for line in lines {
                result.push_str(&format!(" * {}\n", line));
            }
            result.push_str(" */");
            result
        } else {
            format!("/** {} */", self.content)
        }
    }

    /// Format with custom indentation
    pub fn to_typescript_string_with_indent(&self, indent: usize) -> String {
        let indent_str = " ".repeat(indent);
        if self.is_multiline {
            let lines: Vec<&str> = self.content.lines().collect();
            let mut result = format!("{}/**\n", indent_str);
            for line in lines {
                result.push_str(&format!("{} * {}\n", indent_str, line));
            }
            result.push_str(&format!("{} */", indent_str));
            result
        } else {
            format!("{}/** {} */", indent_str, self.content)
        }
    }
}

impl Comment {
    /// Create a new line comment
    pub fn line(content: String) -> Self {
        Self {
            content,
            is_block: false,
        }
    }

    /// Create a new block comment
    pub fn block(content: String) -> Self {
        Self {
            content,
            is_block: true,
        }
    }

    /// Format as TypeScript comment
    pub fn to_typescript_string(&self) -> String {
        if self.is_block {
            if self.content.contains('\n') {
                let lines: Vec<&str> = self.content.lines().collect();
                let mut result = String::from("/*\n");
                for line in lines {
                    result.push_str(&format!(" * {}\n", line));
                }
                result.push_str(" */");
                result
            } else {
                format!("/* {} */", self.content)
            }
        } else {
            format!("// {}", self.content)
        }
    }

    /// Format with custom indentation
    pub fn to_typescript_string_with_indent(&self, indent: usize) -> String {
        let indent_str = " ".repeat(indent);
        if self.is_block {
            if self.content.contains('\n') {
                let lines: Vec<&str> = self.content.lines().collect();
                let mut result = format!("{}/*\n", indent_str);
                for line in lines {
                    result.push_str(&format!("{} * {}\n", indent_str, line));
                }
                result.push_str(&format!("{} */", indent_str));
                result
            } else {
                format!("{}/* {} */", indent_str, self.content)
            }
        } else {
            format!("{}// {}", indent_str, self.content)
        }
    }
}

impl GeneratedFileHeader {
    /// Create a new generated file header with default warning
    pub fn new() -> Self {
        Self {
            warning_message: "DO NOT EDIT - This file is automatically generated.\nAny manual changes will be overwritten on the next generation.\nTo make changes, modify the source code and regenerate this file.".to_string(),
            generator_info: None,
            timestamp: None,
        }
    }

    /// Create with custom warning message
    pub fn with_warning(warning_message: String) -> Self {
        Self {
            warning_message,
            generator_info: None,
            timestamp: None,
        }
    }

    /// Add generator information
    pub fn with_generator_info(mut self, info: String) -> Self {
        self.generator_info = Some(info);
        self
    }

    /// Add timestamp
    pub fn with_timestamp(mut self, timestamp: String) -> Self {
        self.timestamp = Some(timestamp);
        self
    }

    /// Format as TypeScript comment block
    pub fn to_typescript_string(&self) -> String {
        let mut lines = Vec::new();

        // Add warning message
        for line in self.warning_message.lines() {
            lines.push(format!("// {}", line));
        }

        // Add generator info if present
        if let Some(generator_info) = &self.generator_info {
            lines.push("//".to_string());
            lines.push(format!("// Generated by: {}", generator_info));
        }

        // Add timestamp if present
        if let Some(timestamp) = &self.timestamp {
            lines.push(format!("// Generated at: {}", timestamp));
        }

        lines.join("\n")
    }

    /// Format as block comment
    pub fn to_typescript_block_comment(&self) -> String {
        let mut content = self.warning_message.clone();

        if let Some(generator_info) = &self.generator_info {
            content.push_str("\n\nGenerated by: ");
            content.push_str(generator_info);
        }

        if let Some(timestamp) = &self.timestamp {
            content.push_str("\nGenerated at: ");
            content.push_str(timestamp);
        }

        Comment::block(content).to_typescript_string()
    }
}

impl Default for GeneratedFileHeader {
    fn default() -> Self {
        Self::new()
    }
}

/// Helper functions for formatting documentation
pub fn format_param_doc(name: &str, description: &str) -> String {
    format!("@param {} {}", name, description)
}

pub fn format_return_doc(description: &str) -> String {
    format!("@returns {}", description)
}

pub fn format_throws_doc(error_type: &str, description: &str) -> String {
    format!("@throws {{{}}} {}", error_type, description)
}

pub fn format_example_doc(example: &str) -> String {
    format!("@example\n{}", example)
}

/// Create a complete method documentation comment
pub fn create_method_doc(
    description: &str,
    params: &[(String, String)],
    return_desc: Option<&str>,
    throws: &[(String, String)],
    example: Option<&str>,
) -> DocComment {
    let mut lines = vec![description.to_string()];

    if !params.is_empty() {
        lines.push(String::new()); // Empty line
        for (name, desc) in params {
            lines.push(format_param_doc(name, desc));
        }
    }

    if let Some(return_desc) = return_desc {
        lines.push(String::new()); // Empty line
        lines.push(format_return_doc(return_desc));
    }

    if !throws.is_empty() {
        lines.push(String::new()); // Empty line
        for (error_type, desc) in throws {
            lines.push(format_throws_doc(error_type, desc));
        }
    }

    if let Some(example) = example {
        lines.push(String::new()); // Empty line
        lines.push(format_example_doc(example));
    }

    DocComment::multi_line(lines.join("\n"))
}

/// Create a simple class or interface documentation comment
pub fn create_type_doc(description: &str, additional_info: Option<&str>) -> DocComment {
    if let Some(info) = additional_info {
        DocComment::multi_line(format!("{}\n\n{}", description, info))
    } else {
        DocComment::single_line(description.to_string())
    }
}

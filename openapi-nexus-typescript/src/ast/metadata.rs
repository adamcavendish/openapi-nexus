//! TypeScript metadata and documentation
//!
//! This module consolidates comment handling, documentation, and file headers.

use pretty::RcDoc;
use serde::{Deserialize, Serialize};

use crate::emission::error::EmitError;
use openapi_nexus_core::traits::{EmissionContext, ToRcDocWithContext};

/// TypeScript documentation comment
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DocComment {
    pub content: String,
    pub is_multiline: bool,
}

/// Simple TypeScript comment
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Comment {
    pub content: String,
    pub is_block: bool,
}

/// Generated file header
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GeneratedFileHeader {
    pub warning_message: String,
    pub generator_info: Option<String>,
    pub timestamp: Option<String>,
}

impl DocComment {
    /// Create a new documentation comment
    pub fn new(content: String) -> Self {
        let is_multiline = content.contains('\n');
        Self {
            content,
            is_multiline,
        }
    }

    /// Create a single-line doc comment
    pub fn single_line(content: String) -> Self {
        Self {
            content,
            is_multiline: false,
        }
    }

    /// Create a multi-line doc comment
    pub fn multi_line(content: String) -> Self {
        Self {
            content,
            is_multiline: true,
        }
    }
}

impl Comment {
    /// Create a new line comment
    pub fn line(content: String) -> Self {
        Self {
            content,
            is_block: false,
        }
    }

    /// Create a new block comment
    pub fn block(content: String) -> Self {
        Self {
            content,
            is_block: true,
        }
    }
}

impl GeneratedFileHeader {
    /// Create a new generated file header with default warning
    pub fn new() -> Self {
        Self {
            warning_message: "DO NOT EDIT - This file is automatically generated.\nAny manual changes will be overwritten on the next generation.\nTo make changes, modify the source code and regenerate this file.".to_string(),
            generator_info: None,
            timestamp: None,
        }
    }

    /// Create with custom warning message
    pub fn with_warning(warning_message: String) -> Self {
        Self {
            warning_message,
            generator_info: None,
            timestamp: None,
        }
    }

    /// Add generator information
    pub fn with_generator_info(mut self, info: String) -> Self {
        self.generator_info = Some(info);
        self
    }

    /// Add timestamp
    pub fn with_timestamp(mut self, timestamp: String) -> Self {
        self.timestamp = Some(timestamp);
        self
    }
}

impl Default for GeneratedFileHeader {
    fn default() -> Self {
        Self::new()
    }
}

/// Helper functions for formatting documentation
pub fn format_param_doc(name: &str, description: &str) -> String {
    format!("@param {} {}", name, description)
}

pub fn format_return_doc(description: &str) -> String {
    format!("@returns {}", description)
}

pub fn format_throws_doc(error_type: &str, description: &str) -> String {
    format!("@throws {{{}}} {}", error_type, description)
}

pub fn format_example_doc(example: &str) -> String {
    format!("@example\n{}", example)
}

/// Create a complete method documentation comment
pub fn create_method_doc(
    description: &str,
    params: &[(String, String)],
    return_desc: Option<&str>,
    throws: &[(String, String)],
    example: Option<&str>,
) -> DocComment {
    let mut lines = vec![description.to_string()];

    if !params.is_empty() {
        lines.push(String::new()); // Empty line
        for (name, desc) in params {
            lines.push(format_param_doc(name, desc));
        }
    }

    if let Some(return_desc) = return_desc {
        lines.push(String::new()); // Empty line
        lines.push(format_return_doc(return_desc));
    }

    if !throws.is_empty() {
        lines.push(String::new()); // Empty line
        for (error_type, desc) in throws {
            lines.push(format_throws_doc(error_type, desc));
        }
    }

    if let Some(example) = example {
        lines.push(String::new()); // Empty line
        lines.push(format_example_doc(example));
    }

    DocComment::multi_line(lines.join("\n"))
}

/// Create a simple class or interface documentation comment
pub fn create_type_doc(description: &str, additional_info: Option<&str>) -> DocComment {
    if let Some(info) = additional_info {
        DocComment::multi_line(format!("{}\n\n{}", description, info))
    } else {
        DocComment::single_line(description.to_string())
    }
}

// ToRcDocWithContext implementations
impl ToRcDocWithContext for DocComment {
    type Error = EmitError;

    fn to_rcdoc_with_context(
        &self,
        context: &EmissionContext,
    ) -> Result<RcDoc<'static, ()>, EmitError> {
        let indent_str = "  ".repeat(context.indent_level);

        let doc = if self.is_multiline {
            let lines: Vec<&str> = self.content.lines().collect();
            let mut parts = vec![RcDoc::text(format!("{}/**", indent_str))];
            for line in lines {
                parts.push(RcDoc::hardline());
                parts.push(RcDoc::text(format!("{} * {}", indent_str, line)));
            }
            parts.push(RcDoc::hardline());
            parts.push(RcDoc::text(format!("{} */", indent_str)));
            RcDoc::concat(parts)
        } else {
            RcDoc::text(format!("{}/** {} */", indent_str, self.content))
        };

        Ok(doc)
    }
}

impl ToRcDocWithContext for Comment {
    type Error = EmitError;

    fn to_rcdoc_with_context(
        &self,
        context: &EmissionContext,
    ) -> Result<RcDoc<'static, ()>, EmitError> {
        let indent_str = "  ".repeat(context.indent_level);

        let doc = if self.is_block {
            if self.content.contains('\n') {
                let lines: Vec<&str> = self.content.lines().collect();
                let mut parts = vec![RcDoc::text(format!("{}/*", indent_str))];
                for line in lines {
                    parts.push(RcDoc::hardline());
                    parts.push(RcDoc::text(format!("{} * {}", indent_str, line)));
                }
                parts.push(RcDoc::hardline());
                parts.push(RcDoc::text(format!("{} */", indent_str)));
                RcDoc::concat(parts)
            } else {
                RcDoc::text(format!("{}/* {} */", indent_str, self.content))
            }
        } else {
            RcDoc::text(format!("{}// {}", indent_str, self.content))
        };

        Ok(doc)
    }
}

impl ToRcDocWithContext for GeneratedFileHeader {
    type Error = EmitError;

    fn to_rcdoc_with_context(
        &self,
        _context: &EmissionContext,
    ) -> Result<RcDoc<'static, ()>, EmitError> {
        let mut parts = Vec::new();

        // Add warning message
        for line in self.warning_message.lines() {
            parts.push(RcDoc::text(format!("// {}", line)));
            parts.push(RcDoc::hardline());
        }

        // Add generator info if present
        if let Some(generator_info) = &self.generator_info {
            parts.push(RcDoc::text("//"));
            parts.push(RcDoc::hardline());
            parts.push(RcDoc::text(format!("// Generated by: {}", generator_info)));
            parts.push(RcDoc::hardline());
        }

        // Add timestamp if present
        if let Some(timestamp) = &self.timestamp {
            parts.push(RcDoc::text(format!("// Generated at: {}", timestamp)));
            parts.push(RcDoc::hardline());
        }

        Ok(RcDoc::concat(parts))
    }
}

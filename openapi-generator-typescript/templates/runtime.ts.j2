/* tslint:disable */
/* eslint-disable */
/**
 * {{ title }}
 * {{ description }}
 *
 * The version of the OpenAPI document: {{ version }}
 * 
 * NOTE: This file is auto generated.
 * Do not edit this file manually.
 */

/**
 * Configuration parameters for the API client
 */
export interface ConfigurationParameters {
    /** Base URL for API requests */
    basePath?: string;
    /** Custom fetch implementation */
    fetchApi?: FetchAPI;
    /** Request/response middleware */
    middleware?: Middleware[];
    /** Custom query string serializer */
    queryParamsStringify?: (params: HTTPQuery) => string;
    /** Default headers for all requests */
    headers?: HTTPHeaders;
    /** Credentials mode for requests */
    credentials?: RequestCredentials;
}

/**
 * API client configuration
 */
export class Configuration {
    constructor(private configuration: ConfigurationParameters = {}) {}

    get basePath(): string {
        return this.configuration.basePath ?? "http://localhost";
    }

    get fetchApi(): FetchAPI | undefined {
        return this.configuration.fetchApi;
    }

    get middleware(): Middleware[] {
        return this.configuration.middleware ?? [];
    }

    get queryParamsStringify(): (params: HTTPQuery) => string {
        return this.configuration.queryParamsStringify ?? querystring;
    }

    get headers(): HTTPHeaders | undefined {
        return this.configuration.headers;
    }

    get credentials(): RequestCredentials | undefined {
        return this.configuration.credentials;
    }
}

/**
 * Base class for all generated API classes
 */
export class BaseAPI {
    private static readonly jsonRegex = /^(:?application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(:?;.*)?$/i;
    private middleware: Middleware[];

    constructor(protected configuration: Configuration = new Configuration()) {
        this.middleware = configuration.middleware;
    }

    /**
     * Add middleware to this API instance
     */
    withMiddleware<T extends BaseAPI>(this: T, ...middlewares: Middleware[]): T {
        const next = this.clone<T>();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }

    /**
     * Check if the given MIME type is JSON
     */
    protected isJsonMime(mime: string | null | undefined): boolean {
        return mime ? BaseAPI.jsonRegex.test(mime) : false;
    }

    /**
     * Make an HTTP request
     */
    protected async request(context: RequestOpts, initOverrides?: RequestInit): Promise<Response> {
        const { url, init } = await this.createFetchParams(context, initOverrides);
        const response = await this.fetchApi(url, init);
        
        if (response.ok) {
            return response;
        }
        
        throw new ResponseError(response, 'Response returned an error code');
    }

    private async createFetchParams(
        context: RequestOpts,
        initOverrides?: RequestInit
    ): Promise<{ url: string; init: RequestInit }> {
        let url = this.configuration.basePath + context.path;
        
        if (context.query && Object.keys(context.query).length > 0) {
            url += '?' + this.configuration.queryParamsStringify(context.query);
        }

        const headers = { ...this.configuration.headers, ...context.headers };
        Object.keys(headers).forEach(key => {
            if (headers[key] === undefined) {
                delete headers[key];
            }
        });

        let body: any;
        if (isFormData(context.body) || context.body instanceof URLSearchParams || isBlob(context.body)) {
            body = context.body;
        } else if (this.isJsonMime(headers['Content-Type'])) {
            body = JSON.stringify(context.body);
        } else {
            body = context.body;
        }

        const init: RequestInit = {
            method: context.method,
            headers,
            body,
            credentials: this.configuration.credentials,
            ...initOverrides,
        };

        return { url, init };
    }

    private fetchApi = async (url: string, init: RequestInit): Promise<Response> => {
        let fetchParams = { url, init };
        
        // Pre-request middleware
        for (const middleware of this.middleware) {
            if (middleware.pre) {
                const result = await middleware.pre({ fetch: this.fetchApi, ...fetchParams });
                if (result) {
                    fetchParams = result;
                }
            }
        }

        let response: Response | undefined;
        
        try {
            response = await (this.configuration.fetchApi ?? fetch)(fetchParams.url, fetchParams.init);
        } catch (error) {
            // Error middleware
            for (const middleware of this.middleware) {
                if (middleware.onError) {
                    const result = await middleware.onError({
                        fetch: this.fetchApi,
                        url: fetchParams.url,
                        init: fetchParams.init,
                        error,
                        response: response?.clone(),
                    });
                    if (result) {
                        response = result;
                    }
                }
            }
            
            if (!response) {
                throw new FetchError(
                    error instanceof Error ? error : new Error(String(error)),
                    'Request failed'
                );
            }
        }

        // Post-response middleware
        for (const middleware of this.middleware) {
            if (middleware.post) {
                const result = await middleware.post({
                    fetch: this.fetchApi,
                    url: fetchParams.url,
                    init: fetchParams.init,
                    response: response.clone(),
                });
                if (result) {
                    response = result;
                }
            }
        }

        return response;
    };

    private clone<T extends BaseAPI>(this: T): T {
        const constructor = this.constructor as any;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
}

/**
 * Error thrown when a response returns an error status code
 */
export class ResponseError extends Error {
    override name = "ResponseError" as const;
    
    constructor(public response: Response, message?: string) {
        super(message ?? `HTTP ${response.status}: ${response.statusText}`);
    }
}

/**
 * Error thrown when a fetch request fails
 */
export class FetchError extends Error {
    override name = "FetchError" as const;
    
    constructor(public cause: Error, message?: string) {
        super(message ?? cause.message);
    }
}

/**
 * Error thrown when a required parameter is missing
 */
export class RequiredError extends Error {
    override name = "RequiredError" as const;
    
    constructor(public field: string, message?: string) {
        super(message ?? `Required field '${field}' is missing`);
    }
}

// Type definitions

export type FetchAPI = typeof fetch;
export type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD';
export type HTTPHeaders = Record<string, string>;
export type HTTPQuery = Record<string, string | number | boolean | null | Array<string | number | boolean | null> | HTTPQuery>;
export type HTTPBody = any;

export interface RequestOpts {
    path: string;
    method: HTTPMethod;
    headers: HTTPHeaders;
    query?: HTTPQuery;
    body?: HTTPBody;
}

export interface FetchParams {
    url: string;
    init: RequestInit;
}

export interface RequestContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
}

export interface ResponseContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    response: Response;
}

export interface ErrorContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    error: unknown;
    response?: Response;
}

export interface Middleware {
    pre?(context: RequestContext): Promise<FetchParams | void>;
    post?(context: ResponseContext): Promise<Response | void>;
    onError?(context: ErrorContext): Promise<Response | void>;
}

// Utility functions

export function querystring(params: HTTPQuery, prefix: string = ''): string {
    return Object.keys(params)
        .map(key => querystringSingleKey(key, params[key], prefix))
        .filter(part => part.length > 0)
        .join('&');
}

function querystringSingleKey(
    key: string,
    value: string | number | boolean | null | undefined | Array<string | number | boolean | null> | HTTPQuery,
    keyPrefix: string = ''
): string {
    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
    
    if (Array.isArray(value)) {
        const multiValue = value
            .map(v => encodeURIComponent(String(v)))
            .join(`&${encodeURIComponent(fullKey)}=`);
        return `${encodeURIComponent(fullKey)}=${multiValue}`;
    }
    
    if (value instanceof Date) {
        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
    }
    
    if (typeof value === 'object' && value !== null) {
        return querystring(value as HTTPQuery, fullKey);
    }
    
    if (value === null || value === undefined) {
        return '';
    }
    
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
}

function isBlob(value: any): value is Blob {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}

function isFormData(value: any): value is FormData {
    return typeof FormData !== 'undefined' && value instanceof FormData;
}


//! TypeScript code emitter

use pretty::RcDoc;
use snafu::Snafu;

use crate::ast::{
    Class, Enum, Function, Interface, Method, PrimitiveType, Property, TsNode, TypeAlias,
    TypeExpression,
};

const GENERATED_FILE_HEADER: &str = r#"// DO NOT EDIT - This file is automatically generated.
// Any manual changes will be overwritten on the next generation.
// To make changes, modify the source code and regenerate this file.
"#;

/// Error type for TypeScript emission
#[derive(Debug, Snafu)]
#[snafu(visibility(pub))]
pub enum EmitError {
    #[snafu(display("Emit error: {}", message))]
    Generic { message: String },
}

/// TypeScript code emitter
pub struct TypeScriptEmitter;

impl TypeScriptEmitter {
    /// Emit TypeScript code from AST nodes
    pub fn emit(&self, nodes: &[TsNode]) -> Result<String, EmitError> {
        let mut docs = Vec::new();

        // Add generated file header
        docs.push(RcDoc::text(GENERATED_FILE_HEADER));

        // Check if this is an API class file and add runtime imports
        let needs_runtime_imports = self.needs_runtime_imports(nodes);
        if needs_runtime_imports {
            docs.push(RcDoc::text(
                "import { BaseAPI, RequestContext } from '../runtime/api';\n",
            ));
            docs.push(RcDoc::text(
                "import { Configuration } from '../runtime/config';\n",
            ));
        }

        for node in nodes {
            let doc = self.emit_node(node)?;
            docs.push(doc);
        }

        let combined = RcDoc::intersperse(docs, RcDoc::line());
        Ok(combined.pretty(80).to_string())
    }

    /// Check if nodes contain API classes that need runtime imports
    fn needs_runtime_imports(&self, nodes: &[TsNode]) -> bool {
        nodes.iter().any(|node| {
            if let TsNode::Class(class) = node {
                class
                    .extends
                    .as_ref()
                    .is_some_and(|extends| extends == "BaseAPI")
            } else {
                false
            }
        })
    }

    fn emit_node(&self, node: &TsNode) -> Result<RcDoc<'_, ()>, EmitError> {
        match node {
            TsNode::Interface(interface) => self.emit_interface(interface),
            TsNode::TypeAlias(type_alias) => self.emit_type_alias(type_alias),
            TsNode::Enum(enum_def) => self.emit_enum(enum_def),
            TsNode::Function(function) => self.emit_function(function),
            TsNode::Class(class_def) => self.emit_class(class_def),
            TsNode::Import(_) => Ok(RcDoc::text("// TODO: Import emission")),
            TsNode::Export(_) => Ok(RcDoc::text("// TODO: Export emission")),
        }
    }

    fn emit_interface(&self, interface: &Interface) -> Result<RcDoc<'_, ()>, EmitError> {
        let mut result = String::new();

        // Add documentation
        if let Some(docs) = &interface.documentation {
            result.push_str(&format!("/**\n * {}\n */\n", docs));
        }

        // Add interface declaration
        result.push_str("export interface ");
        result.push_str(&interface.name);

        // Add generics
        if !interface.generics.is_empty() {
            let generic_names: Vec<String> =
                interface.generics.iter().map(|g| g.name.clone()).collect();
            result.push_str(&format!("<{}>", generic_names.join(", ")));
        }

        // Add extends
        if !interface.extends.is_empty() {
            result.push_str(" extends ");
            result.push_str(&interface.extends.join(", "));
        }

        // Add properties
        if interface.properties.is_empty() {
            result.push_str(" {}");
        } else {
            result.push_str(" {\n");
            for prop in &interface.properties {
                result.push_str(&self.emit_property_string(prop)?);
                result.push('\n');
            }
            result.push('}');
        }

        Ok(RcDoc::text(result))
    }

    fn emit_property_string(&self, property: &Property) -> Result<String, EmitError> {
        let mut result = String::new();

        if let Some(docs) = &property.documentation {
            result.push_str(&format!("  /** {} */\n", docs));
        }

        result.push_str("  ");
        result.push_str(&property.name);

        if property.optional {
            result.push('?');
        }

        result.push_str(": ");
        result.push_str(&self.emit_type_expression_string(&property.type_expr)?);
        result.push(';');

        Ok(result)
    }

    fn emit_type_alias(&self, type_alias: &TypeAlias) -> Result<RcDoc<'_, ()>, EmitError> {
        let mut result = String::new();

        if let Some(docs) = &type_alias.documentation {
            result.push_str(&format!("/**\n * {}\n */\n", docs));
        }

        result.push_str("export type ");
        result.push_str(&type_alias.name);

        if !type_alias.generics.is_empty() {
            let generic_names: Vec<String> =
                type_alias.generics.iter().map(|g| g.name.clone()).collect();
            result.push_str(&format!("<{}>", generic_names.join(", ")));
        }

        result.push_str(" = ");
        result.push_str(&self.emit_type_expression_string(&type_alias.type_expr)?);
        result.push(';');

        Ok(RcDoc::text(result))
    }

    fn emit_enum(&self, enum_def: &Enum) -> Result<RcDoc<'_, ()>, EmitError> {
        let mut result = String::new();

        if let Some(docs) = &enum_def.documentation {
            result.push_str(&format!("/**\n * {}\n */\n", docs));
        }

        result.push_str("export enum ");
        result.push_str(&enum_def.name);
        result.push_str(" {\n");

        for variant in &enum_def.variants {
            result.push_str("  ");
            result.push_str(&variant.name);
            if let Some(value) = &variant.value {
                result.push_str(&format!(" = \"{}\"", value));
            }
            result.push_str(",\n");
        }

        result.push('}');

        Ok(RcDoc::text(result))
    }

    fn emit_function(&self, function: &Function) -> Result<RcDoc<'_, ()>, EmitError> {
        let mut result = String::new();

        if let Some(docs) = &function.documentation {
            result.push_str(&format!("/**\n * {}\n */\n", docs));
        }

        result.push_str("export ");
        if function.is_async {
            result.push_str("async ");
        }
        result.push_str("function ");
        result.push_str(&function.name);

        // Add generics
        if !function.generics.is_empty() {
            let generic_names: Vec<String> =
                function.generics.iter().map(|g| g.name.clone()).collect();
            result.push_str(&format!("<{}>", generic_names.join(", ")));
        }

        result.push('(');

        let param_strings: Vec<String> = function
            .parameters
            .iter()
            .map(|param| {
                let mut param_str = param.name.clone();
                if param.optional {
                    param_str.push('?');
                }
                if let Some(type_expr) = &param.type_expr {
                    param_str.push_str(&format!(
                        ": {}",
                        self.emit_type_expression_string(type_expr)
                            .unwrap_or_else(|_| "any".to_string())
                    ));
                }
                param_str
            })
            .collect();

        result.push_str(&param_strings.join(", "));
        result.push(')');

        if let Some(return_type) = &function.return_type {
            result.push_str(&format!(
                ": {}",
                self.emit_type_expression_string(return_type)?
            ));
        }

        result.push_str(
            " {\n  // TODO: Implement function body\n  throw new Error('Not implemented');\n}",
        );

        Ok(RcDoc::text(result))
    }

    fn emit_class(&self, class_def: &Class) -> Result<RcDoc<'_, ()>, EmitError> {
        let mut result = String::new();

        if let Some(docs) = &class_def.documentation {
            result.push_str(&format!("/**\n * {}\n */\n", docs));
        }

        result.push_str("export class ");
        result.push_str(&class_def.name);

        if !class_def.generics.is_empty() {
            let generic_names: Vec<String> =
                class_def.generics.iter().map(|g| g.name.clone()).collect();
            result.push_str(&format!("<{}>", generic_names.join(", ")));
        }

        if let Some(extends) = &class_def.extends {
            result.push_str(&format!(" extends {}", extends));
        }

        if !class_def.implements.is_empty() {
            result.push_str(&format!(" implements {}", class_def.implements.join(", ")));
        }

        result.push_str(" {\n");

        // Add properties
        for prop in &class_def.properties {
            result.push_str(&self.emit_property_string(prop)?);
            result.push('\n');
        }

        // Add methods
        for method in &class_def.methods {
            result.push_str(&self.emit_method_string(
                method,
                &class_def.name,
                &class_def.extends,
            )?);
            result.push('\n');
        }

        result.push('}');

        Ok(RcDoc::text(result))
    }

    fn emit_method_string(
        &self,
        method: &Method,
        class_name: &str,
        extends: &Option<String>,
    ) -> Result<String, EmitError> {
        let mut result = String::new();

        if let Some(docs) = &method.documentation {
            result.push_str(&format!("  /**\n   * {}\n   */\n", docs));
        }

        result.push_str("  ");
        result.push_str(&method.name);
        result.push('(');

        let param_strings: Vec<String> = method
            .parameters
            .iter()
            .map(|param| {
                let mut param_str = param.name.clone();
                if param.optional {
                    param_str.push('?');
                }
                if let Some(type_expr) = &param.type_expr {
                    param_str.push_str(&format!(
                        ": {}",
                        self.emit_type_expression_string(type_expr)
                            .unwrap_or_else(|_| "any".to_string())
                    ));
                }
                param_str
            })
            .collect();

        result.push_str(&param_strings.join(", "));
        result.push(')');

        if let Some(return_type) = &method.return_type {
            result.push_str(&format!(
                ": {}",
                self.emit_type_expression_string(return_type)?
            ));
        }

        result.push_str(" {\n");

        // Add method implementation based on method name
        match method.name.as_str() {
            "constructor" => {
                match class_name {
                    "BaseAPI" => {
                        // BaseAPI has no parent class, just assign configuration
                        result.push_str("    this.configuration = configuration;\n");
                    }
                    "RequiredError" => {
                        // RequiredError extends Error, pass the field parameter to super
                        result.push_str("    super(field);\n");
                        result.push_str("    this.field = field;\n");
                    }
                    _ => {
                        // For other classes, use the default super call
                        if extends.is_some() {
                            result.push_str("    super(configuration);\n");
                        } else {
                            result.push_str("    // TODO: Implement constructor\n");
                        }
                    }
                }
            }
            "get" => {
                result.push_str("    return fetch(`${this.baseUrl}${path}`, {\n");
                result.push_str("      method: 'GET',\n");
                result.push_str("      headers: this.headers,\n");
                result.push_str("    }).then(response => response.json());\n");
            }
            "post" => {
                result.push_str("    return fetch(`${this.baseUrl}${path}`, {\n");
                result.push_str("      method: 'POST',\n");
                result.push_str("      headers: {\n");
                result.push_str("        'Content-Type': 'application/json',\n");
                result.push_str("        ...this.headers,\n");
                result.push_str("      },\n");
                result.push_str("      body: body ? JSON.stringify(body) : undefined,\n");
                result.push_str("    }).then(response => response.json());\n");
            }
            "put" => {
                result.push_str("    return fetch(`${this.baseUrl}${path}`, {\n");
                result.push_str("      method: 'PUT',\n");
                result.push_str("      headers: {\n");
                result.push_str("        'Content-Type': 'application/json',\n");
                result.push_str("        ...this.headers,\n");
                result.push_str("      },\n");
                result.push_str("      body: body ? JSON.stringify(body) : undefined,\n");
                result.push_str("    }).then(response => response.json());\n");
            }
            "delete" => {
                result.push_str("    return fetch(`${this.baseUrl}${path}`, {\n");
                result.push_str("      method: 'DELETE',\n");
                result.push_str("      headers: this.headers,\n");
                result.push_str("    }).then(response => response.json());\n");
            }
            _ => {
                result.push_str("    // TODO: Implement method\n");
                // Add a return statement if the method has a return type
                if let Some(return_type) = &method.return_type {
                    let return_type_str = self
                        .emit_type_expression_string(return_type)
                        .unwrap_or_else(|_| "any".to_string());
                    if return_type_str != "void" && return_type_str != "undefined" {
                        result.push_str("    throw new Error('Not implemented');\n");
                    }
                }
            }
        }

        result.push_str("  }");

        Ok(result)
    }

    /// Emit a TypeExpression as a pretty-printed RcDoc
    fn emit_type_expression_doc(
        &self,
        type_expr: &TypeExpression,
    ) -> Result<RcDoc<'_, ()>, EmitError> {
        self.emit_type_expression_doc_with_indent(type_expr, 0)
    }

    /// Emit a TypeExpression as a pretty-printed RcDoc with specified indentation level
    fn emit_type_expression_doc_with_indent(
        &self,
        type_expr: &TypeExpression,
        indent_level: usize,
    ) -> Result<RcDoc<'_, ()>, EmitError> {
        match type_expr {
            TypeExpression::Primitive(primitive) => {
                let type_name = match primitive {
                    PrimitiveType::String => "string",
                    PrimitiveType::Number => "number",
                    PrimitiveType::Boolean => "boolean",
                    PrimitiveType::Null => "null",
                    PrimitiveType::Undefined => "undefined",
                    PrimitiveType::Any => "any",
                    PrimitiveType::Unknown => "unknown",
                    PrimitiveType::Void => "void",
                    PrimitiveType::Never => "never",
                };
                Ok(RcDoc::text(type_name))
            }
            TypeExpression::Array(item_type) => {
                let item_doc = self.emit_type_expression_doc_with_indent(item_type, indent_level)?;
                Ok(RcDoc::text("Array<")
                    .append(item_doc)
                    .append(RcDoc::text(">")))
            }
            TypeExpression::Union(types) => {
                let type_docs: Result<Vec<RcDoc<'_, ()>>, _> = types
                    .iter()
                    .map(|t| self.emit_type_expression_doc_with_indent(t, indent_level))
                    .collect();
                let docs = type_docs?;
                if docs.len() == 1 {
                    Ok(docs[0].clone())
                } else {
                    let separator = RcDoc::text(" | ");
                    Ok(RcDoc::intersperse(docs, separator).group())
                }
            }
            TypeExpression::Intersection(types) => {
                let type_docs: Result<Vec<RcDoc<'_, ()>>, _> = types
                    .iter()
                    .map(|t| self.emit_type_expression_doc_with_indent(t, indent_level))
                    .collect();
                let docs = type_docs?;
                if docs.len() == 1 {
                    Ok(docs[0].clone())
                } else {
                    let separator = RcDoc::text(" & ");
                    Ok(RcDoc::intersperse(docs, separator))
                }
            }
            TypeExpression::Reference(name) => Ok(RcDoc::text(name.clone())),
            TypeExpression::Literal(value) => Ok(RcDoc::text(value.clone())),
            TypeExpression::Object(properties) => {
                if properties.is_empty() {
                    Ok(RcDoc::text("{}"))
                } else {
                    // Check if this object should be formatted inline or multiline
                    let should_multiline = self.should_format_object_multiline(properties);
                    if should_multiline {
                        // Multi-line format with proper indentation
                        let mut result = RcDoc::text("{");
                        result = result.append(RcDoc::line());
                        
                        let current_indent = "  ".repeat(indent_level + 1);
                        for (i, (name, type_expr)) in properties.iter().enumerate() {
                            let type_doc = self.emit_type_expression_doc_with_indent(type_expr, indent_level + 1)?;
                            let prop_doc = RcDoc::text(current_indent.clone())
                                .append(RcDoc::text(name.clone()))
                                .append(RcDoc::text(": "))
                                .append(type_doc)
                                .append(RcDoc::text(";"));
                            
                            result = result.append(prop_doc);
                            if i < properties.len() - 1 {
                                result = result.append(RcDoc::line());
                            }
                        }
                        
                        result = result.append(RcDoc::line());
                        let closing_indent = "  ".repeat(indent_level);
                        result = result.append(RcDoc::text(closing_indent));
                        result = result.append(RcDoc::text("}"));
                        Ok(result)
                    } else {
                        // Inline format for simple objects
                        let prop_docs: Result<Vec<RcDoc<'_, ()>>, _> = properties
                            .iter()
                            .map(|(name, type_expr)| {
                                let type_doc = self.emit_type_expression_doc_with_indent(type_expr, indent_level)?;
                                Ok(RcDoc::text(name.clone())
                                    .append(RcDoc::text(": "))
                                    .append(type_doc))
                            })
                            .collect();

                        let props = prop_docs?;
                        let separator = RcDoc::text("; ");
                        Ok(RcDoc::text("{ ")
                            .append(RcDoc::intersperse(props, separator))
                            .append(RcDoc::text(" }"))
                            .group())
                    }
                }
            }
            TypeExpression::Function(signature) => {
                let param_docs: Vec<RcDoc<'_, ()>> = signature
                    .parameters
                    .iter()
                    .map(|param| {
                        let mut param_doc = RcDoc::text(param.name.clone());
                        if param.optional {
                            param_doc = param_doc.append(RcDoc::text("?"));
                        }
                        if let Some(type_expr) = &param.type_expr {
                            param_doc = param_doc.append(RcDoc::text(": "));
                            match self.emit_type_expression_doc_with_indent(type_expr, indent_level) {
                                Ok(type_doc) => param_doc = param_doc.append(type_doc),
                                Err(_) => param_doc = param_doc.append(RcDoc::text("any")),
                            }
                        }
                        param_doc
                    })
                    .collect();

                let params = if param_docs.is_empty() {
                    RcDoc::text("()")
                } else {
                    RcDoc::text("(")
                        .append(RcDoc::intersperse(param_docs, RcDoc::text(", ")))
                        .append(RcDoc::text(")"))
                };

                let mut func_doc = params;
                if let Some(return_type) = &signature.return_type {
                    let return_doc = self.emit_type_expression_doc_with_indent(return_type, indent_level)?;
                    func_doc = func_doc.append(RcDoc::text(" => ")).append(return_doc);
                }

                Ok(func_doc)
            }
            TypeExpression::Tuple(types) => {
                let type_docs: Result<Vec<RcDoc<'_, ()>>, _> = types
                    .iter()
                    .map(|t| self.emit_type_expression_doc_with_indent(t, indent_level))
                    .collect();
                let docs = type_docs?;
                Ok(RcDoc::text("[")
                    .append(RcDoc::intersperse(docs, RcDoc::text(", ")))
                    .append(RcDoc::text("]")))
            }
            TypeExpression::Generic(name) => Ok(RcDoc::text(name.clone())),
            TypeExpression::IndexSignature(key_type, value_type) => {
                let value_doc = self.emit_type_expression_doc_with_indent(value_type, indent_level)?;
                Ok(RcDoc::text("[key: ")
                    .append(RcDoc::text(key_type.clone()))
                    .append(RcDoc::text("]: "))
                    .append(value_doc))
            }
        }
    }

    /// Determine if an object should be formatted multiline based on complexity
    fn should_format_object_multiline(
        &self,
        properties: &std::collections::BTreeMap<String, TypeExpression>,
    ) -> bool {
        // Format multiline if:
        // 1. More than 2 properties
        // 2. Any property has a complex nested type
        if properties.len() > 2 {
            return true;
        }

        for type_expr in properties.values() {
            if self.is_complex_type(type_expr) {
                return true;
            }
        }

        false
    }

    /// Check if a type expression is complex (nested objects, arrays, unions, etc.)
    fn is_complex_type(&self, type_expr: &TypeExpression) -> bool {
        match type_expr {
            TypeExpression::Object(properties) => {
                // Only consider objects complex if they have more than 2 properties
                // or contain nested complex types
                if properties.len() > 2 {
                    return true;
                }
                for prop_type in properties.values() {
                    if self.is_complex_type(prop_type) {
                        return true;
                    }
                }
                false
            }
            TypeExpression::Array(_) => true,
            TypeExpression::Union(types) => types.len() > 1,
            TypeExpression::Intersection(types) => types.len() > 1,
            TypeExpression::Function(_) => true,
            TypeExpression::Tuple(types) => types.len() > 1,
            _ => false,
        }
    }

    fn emit_type_expression_string(&self, type_expr: &TypeExpression) -> Result<String, EmitError> {
        let doc = self.emit_type_expression_doc(type_expr)?;
        Ok(doc.pretty(80).to_string())
    }
}
